{
  "version": 3,
  "sources": ["../src/webviews/ClientItem.ts", "../src/bothside/RpcChannel.ts", "../src/webviews/RpcClient.ts", "../src/webviews/exemples/Exemple.ts"],
  "sourcesContent": ["import { UEntry } from \"../bothside/UEntry\";\nimport { UExemple } from \"../bothside/UExemple\";\nimport { UOeuvre } from \"../bothside/UOeuvre\";\nimport { Entry } from \"./entries/Entry\";\nimport { Exemple } from \"./exemples/Exemple\";\nimport { Oeuvre } from \"./oeuvres/Oeuvre\";\nimport { FullEntry } from \"../extension/models/Entry\";\nimport { FullOeuvre } from \"../extension/models/Oeuvre\";\nimport { FullExemple } from \"../extension/models/Exemple\";\n\ntype Tel_u = FullEntry | FullOeuvre | FullExemple;\ntype Tel = typeof Entry | typeof Oeuvre | typeof Exemple;\n\nexport abstract class ClientItem<Tel, Tel_u> {\n  data: Tel_u;\n  static klass: any;\n  static allItems: any[];\n  static deserializeItems(items: string[]) {\n    this.allItems = items.map( item => new this.klass(JSON.parse(item)));\n    return this.allItems;\n  }\n  constructor(itemData: Tel_u){\n    this.data = itemData;\n  } \n}", "/**\n * Canal RPC pour communiquer entre extension et webview.\n * Les deux c\u00F4t\u00E9s chargent ce module.\n */\ntype Request = {\n  id: number;\n  method: string;\n  params: any;\n};\n\ntype Response = {\n  id: number;\n  result: any;\n};\n\ntype Notification = {\n  method: string;\n  params: any;\n};\n\nexport class RpcChannel {\n  private counter = 0;\n  private pending = new Map<number, (value: any) => void>();\n  private handlers = new Map<string, (params: any) => any>();\n\n  constructor(\n    private sender: (msg: any) => void,\n    private receiver: (cb: (msg: any) => void) => void\n  ) {\n    this.receiver(this.handleMessage.bind(this));\n  }\n\n  private handleMessage(msg: any) {\n    if (\"id\" in msg && \"method\" in msg) {\n      // C\u2019est une requ\u00EAte (ask c\u00F4t\u00E9 oppos\u00E9)\n      const handler = this.handlers.get(msg.method);\n      if (handler) {\n        Promise.resolve(handler(msg.params)).then((result) => {\n          this.sender({ id: msg.id, result });\n        });\n      }\n    } else if (\"id\" in msg && \"result\" in msg) {\n      // R\u00E9ponse\n      const cb = this.pending.get(msg.id);\n      if (cb) {\n        cb(msg.result);\n        this.pending.delete(msg.id);\n      }\n    } else if (\"method\" in msg) {\n      // Notification (notify c\u00F4t\u00E9 oppos\u00E9)\n      const handler = this.handlers.get(msg.method);\n      if (handler) {\n        handler(msg.params);\n      }\n    }\n  }\n\n  ask(method: string, params?: any): Promise<any> {\n    const id = this.counter++;\n    const req: Request = { id, method, params };\n    this.sender(req);\n    return new Promise((resolve) => {\n      this.pending.set(id, resolve);\n    });\n  }\n\n  notify(method: string, params?: any) {\n    const notif: Notification = { method, params };\n    this.sender(notif);\n  }\n\n  on(method: string, handler: (params: any) => any) {\n    this.handlers.set(method, handler);\n  }\n}\n", "import { RpcChannel } from \"../bothside/RpcChannel\";\n\nexport function createRpcClient() {\n  return new RpcChannel(\n    (msg) => window.parent.postMessage(msg, \"*\"),\n    (cb) => window.addEventListener(\"message\", (event) => cb(event.data))\n  );\n}\n", "// import '../InterCom-tests';\nimport { RpcChannel } from '../../bothside/RpcChannel';\nimport { UExemple } from '../../bothside/UExemple';\nimport { FullExemple } from '../../extension/models/Exemple';\nimport { ClientItem } from '../ClientItem';\nimport { ClientPanel } from '../ClientPanel';\nimport { createRpcClient } from '../RpcClient';\n\nexport class Exemple extends ClientItem<UExemple, FullExemple> {\n  static readonly minName = 'exemple';\n  static readonly klass = Exemple;\n\n//   static readonly minName = 'exemple';\n  \n//   /**\n//    * Filtrage des exemples \n//    * M\u00E9thode sp\u00E9cifique Exemple\n//    * \n//    * En mode \"normal\"\n//    * Le filtrage, sauf indication contraire, se fait par rapport aux\n//    * titres de film. Le m\u00E9canisme est le suivant : l'user tape un\n//    * d\u00E9but de titres de film. On en d\u00E9duit les titres gr\u00E2ce \u00E0 la\n//    * m\u00E9thode de la classe Oeuvre. On prend l'identifiant et on \n//    * affiche tous les exemples du film voulu.\n//    * \n//    * En mode \"Entr\u00E9e\", l'utilisateur tape une entr\u00E9e du dictionnaire\n//    * et la m\u00E9thode renvoie tous les exemples concernant cette entr\u00E9e.\n//    * \n//    * En mode \"Contenu\", la recherche se fait sur le contenu, partout\n//    * et sur toutes les entr\u00E9es.\n//    * \n//    * QUESTION Comment faire la diff\u00E9rence entre les diff\u00E9rents modes\n//    * de recherche ? peut-\u00EAtre avec un pr\u00E9fix ('content' pour recher-\n//    * che sur le contenu, 'dico:' ou 'entree:' pour la recherche sur \n//    * les entr\u00E9es et rien pour la recherche sur le film)\n//    */\n//   protected static searchMatchingItems(searched: string): CachedExempleData[] {\n//     const searchLower = StringNormalizer.toLower(searched);\n//     const searchRa = StringNormalizer.rationalize(searched);\n//     const mode: string = 'by oeuvre' ; // doit pouvoir \u00EAtre d\u00E9termin\u00E9 depuis searchLower\n\n//     switch (mode) {\n//       case 'by oeuvre':\n//         /*\n//         TODO \u00C7a doit \u00EAtre affin\u00E9 : \n//         - on appelle la m\u00E9thode Oeuvre.searchMatchingItems(searchLower) pour\n//           obtenir les oeuvres possibles\n//         - on boucle sur chaque oeuvre pour obtenir les exemples. On retourne \n//           la liste obtenue.\n//         */\n//         const oeuvreId = 'DITD' ; // \u00E0 d\u00E9terminer en fonction du d\u00E9but cherch\u00E9\n//         return this.getByOeuvre(oeuvreId) as CachedExempleData[];\n//       case 'by entry':\n//         return [] as CachedExempleData[];\n//       case 'by content':\n//         return this.filter((exemple: any) => {\n//           return exemple.content_min.includes(searchLower) ||\n//             exemple.content_min_ra.includes(searchRa);\n//         }) as CachedExempleData[];\n//       default:\n//         return [] ; // ne doit jamais \u00EAtre atteint, juste pour lint\n//     }\n//  }\n\n//   /**\n//    * R\u00E9cup\u00E8re tous les exemples associ\u00E9s \u00E0 une oeuvre\n//    * M\u00E9thode sp\u00E9cifique Exemple\n//    */\n//   static getByOeuvre(oeuvreId: string): CachedExempleData[] {\n//     return this.filter((exemple: any) => exemple.oeuvre_id === oeuvreId) as CachedExempleData[];\n//   }\n//   /**\n//    * Post-traitement apr\u00E8s affichage : ajouter les titres des films\n//    * IMPORTANT: Cette m\u00E9thode est appel\u00E9e apr\u00E8s l'affichage initial\n//    * \n//    * Fonctionnement\n//    * --------------\n//    * Pour optimiser le traitement, en consid\u00E9rant qu'on peut avoir\n//    * des milliers d'exemples, on ne passe pas par le DOM mais par\n//    * les donn\u00E9es (getAll). Puisqu'elles sont relev\u00E9es dans l'ordre,\n//    * c'est-\u00E0-dire par film, il suffit d'ajouter un titre au premier\n//    * exemple qu'on trouve qui a un film diff\u00E9rent du pr\u00E9c\u00E9dent.\n//    * \n//    */\n//   static afterDisplayItems(): boolean {\n//     console.log('[EXEMPLES] afterDisplayItems - Grouping examples by oeuvre');\n    \n//     const mainConteneur = this.container as HTMLElement | null ;\n    \n//     if ( mainConteneur === null ) {\n//       // \u00C7a ne devrait jamais arriver\n//       console.error('[EXEMPLES] No container found for grouping');\n//       return false;\n//     }\n//     // Film courant\n//     let currentOeuvreId = '' ;\n//     this.cacheManager.getAll().forEach(exemple => {\n//       if ( exemple.oeuvre_id === currentOeuvreId ) { return ; }\n//       // Le film change, il faut mettre un titre avant\n//       const domObj = document.querySelector(`main#items > div.item[data-id=\"${exemple.id}\"]`) as HTMLDivElement ;\n//       currentOeuvreId = exemple.oeuvre_id as string ;\n//       const titleObj = document.createElement('h2');\n//       const oeuvre = this.cacheManager.get(exemple.oeuvre_id as string);\n//       console.log(\"oeuvre r\u00E9pondant \u00E0 l'id %s\", currentOeuvreId, oeuvre);\n//       if ( !oeuvre ) {\n//         console.log(\"Oeuvre introuvable, this.cacheManager vaut\", this.cacheManager);\n//         throw new Error(\"L'\u0153uvre devrait \u00EAtre d\u00E9finie.\");\n//       }\n//       const titre = oeuvre ? oeuvre.titre_affiche : \"\u0153uvre introuvable\" ;\n//       console.log(\"Titre\", titre);\n//       titleObj.innerHTML = titre ;\n//        // Ajouter bouton d'ajout d'exemple\n//       const btnAdd = document.createElement('button');\n//       btnAdd.className = 'btn-add';\n//       btnAdd.innerHTML = '<i class=\"codicon codicon-add\"></i>';\n//       btnAdd.setAttribute('data-oeuvre_id', currentOeuvreId);\n//       titleObj.appendChild(btnAdd);\n//       domObj.parentNode?.insertBefore(titleObj, domObj);\n//     });\n//     console.log('[EXEMPLES] Titling completed');\n//     return true;\n//   }\n}\nclass PanelExemple extends ClientPanel {\n static titName = 'Exemple';\n}\n\n\nconst RpcEx: RpcChannel = createRpcClient();\nRpcEx.on('populate', (params) => {\n  const items = Exemple.deserializeItems(params.data);\n  console.log(\"[CLIENT-Exemple] Items d\u00E9s\u00E9rialis\u00E9s\", items);\n});\n(window as any).Exemple = Exemple;"],
  "mappings": "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",
  "names": []
}
